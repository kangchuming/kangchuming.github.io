# 快速排序（QuickSort）实现

快速排序是一种高效的排序算法，采用分治策略，通过选择基准元素（pivot）将数组分为两部分，然后递归排序各个部分。本文介绍一种简洁易懂的 JavaScript 快速排序实现。

## 实现代码

```javascript
function quickSort(arr) {
    // 基本情况：数组长度小于等于1时，已经有序
    if(arr.length <= 1) return arr;

    // 随机选择基准元素，提高对不同输入的鲁棒性
    let pivot = arr[Math.floor(Math.random() * arr.length)];

    // 创建三个数组，分别存储小于、等于和大于基准元素的值
    let [left, mid, right] = [[], [], []];

    // 遍历原数组，将元素分配到三个数组中
    for(let item of arr) {
        if(item < pivot) {
            left.push(item);
        } else if(item > pivot) {
            right.push(item);
        } else {
            mid.push(item);
        }
    }

    // 递归排序左右两部分，然后合并结果
    return [...quickSort(left), ...mid, ...quickSort(right)];
}
```

## 使用示例

```javascript
console.log(quickSort([3, 6, 2, 8, 1, 5, 9, 4, 7])); 
// 输出: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 算法分析

### 特点

1. **三路快排**：这种实现采用了三路快排的思想，将数组分为小于、等于和大于基准元素的三部分，有效处理重复元素
2. **随机选择基准**：通过随机选择基准元素，降低遇到最坏情况的概率
3. **简洁易读**：代码结构清晰，易于理解和记忆

### 性能分析

- **时间复杂度**：
  - 平均情况：O(n log n)
  - 最坏情况：O(n²)（当数组已经有序或完全逆序时）
  - 最好情况：O(n log n)

- **空间复杂度**：
  - O(n)，主要用于存储三个临时数组
  - 递归调用栈在最坏情况下可能达到 O(n)

### 优化方向

1. **原地排序**：可以通过分区操作（partition）实现原地排序，减少空间消耗
2. **尾递归优化**：对较大的子数组使用递归，较小的子数组使用迭代，降低栈溢出风险
3. **三数取中**：使用首、中、尾三个元素的中位数作为基准元素，进一步提高算法稳定性

## 应用场景

1. **通用排序**：作为通用排序算法使用，特别是对大型数据集
2. **快速选择**：寻找数组中第 k 小的元素（只需要对一侧进行递归）
3. **去重并排序**：利用三路快排的特性，可以在排序的同时识别重复元素

## 总结

这个快速排序实现虽然不是最优的（从空间复杂度角度），但具有良好的可读性和稳定性。它通过随机选择基准元素和三路分区策略，在平均情况下能够实现 O(n log n) 的时间复杂度，适用于大多数排序场景。